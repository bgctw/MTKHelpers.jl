var documenterSearchIndex = {"docs":
[{"location":"write_csv_cv/#Reading-and-Writing-DataFrames-that-contain-ComponentArrays","page":"Writing/Reading ComponentVectors","title":"Reading and Writing DataFrames that contain ComponentArrays","text":"","category":"section"},{"location":"write_csv_cv/","page":"Writing/Reading ComponentVectors","title":"Writing/Reading ComponentVectors","text":"MTKHelpers supports setting parameters that are symbolic arrays, by specifying them as ComponentVector.","category":"page"},{"location":"write_csv_cv/","page":"Writing/Reading ComponentVectors","title":"Writing/Reading ComponentVectors","text":"Therefore, it is often useful to store parameters as ComponentVector in  one columns of a DataFrame. A DataFrame with such a columns, however,  is not easily written and retrieved from a interoperable file, such as CSV.","category":"page"},{"location":"write_csv_cv/","page":"Writing/Reading ComponentVectors","title":"Writing/Reading ComponentVectors","text":"The following functions write and read data of such a DataFrame in CSV format that can be read by other tools. By using additional information on the Axes stored in comments, the ComponentVectors can be reconstructed.","category":"page"},{"location":"write_csv_cv/#MTKHelpers.write_csv_cv","page":"Writing/Reading ComponentVectors","title":"MTKHelpers.write_csv_cv","text":"write_csv_cv(con::IO, df0::DataFrame)\nread_csv_cv(con::IO)::DataFrame\n\nWrite/Read a DataFrame that contains columns of type ComponentArrays    to a CSV file. Each ComponentArray column is replaced by length(cv) columns, and information on the axis is generated as a comment in front of the CSV.\n\nWhen re-reading the CSV, the respective ComponentArrays are recreated  usingn this information and are replaced for the read plain columns.\n\nMake sure to not duplicate names. If there is a ComponentArray column u0 containing three Floats, the following three columns are added  (and should not exist before): u0_1, u0_2, u0_3.\n\n\n\n\n\n","category":"function"},{"location":"pde_dev/#PDE-support-developer-notes","page":"PDE support","title":"PDE support developer notes","text":"","category":"section"},{"location":"pde_dev/#Depth-distributions","page":"PDE support","title":"Depth distributions","text":"","category":"section"},{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"The inputs to the system have to be described by a differential across depth. The following derivation provides an exponential function f(zb) = a e^bz, such that int_z_m^0 f(z) dz = 1. Such a function can be used to distribute total inputs across depth.","category":"page"},{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"Derivation: for positive x = -z:","category":"page"},{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"beginaligned\nf(x) = a e^-bx\n\nF(x) = fraca-b e^-bx \n\nleft F(x) right_0^x_m = fraca-b left( e^-b x_m -1 right) = 1\n\na = fracb1 - e^-bx_m\n\nf(x) = fracb1 - e^-bx_m e^-bx\n\nF(x) = frac1e^-bx_m - 1 left( e^-bx -1 right)\nendaligned","category":"page"},{"location":"concrete_parupdater/#Concrete-ProblemUpdater","page":"Type inference","title":"Concrete ProblemUpdater","text":"","category":"section"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"The default-implementations of ODEParSetter and ParUpdater do not store much information in type parameters to avoid long compilation times.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"The disadvantage is, that the result of some operations is not fully type- inferred, especially when dealing with ComponentArrays that store information in their type signature. The results of the folloginw calls are not inferred (x is stands in for either state, par, or paropt):","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"axis_x(pset)\nlabel_x(pset, ...) \nget_paropt(pset, ...), and get_paropt_labeled(pset, ...)\nupdate_statepar and remake\ncount_x(pset) is inferred but no known at compile time and   can not be used to create StaticArrays","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"Therefore, this package provides function get_concrete, that provides a concrete-typed version of a type.","category":"page"},{"location":"concrete_parupdater/#MTKHelpers.get_concrete","page":"Type inference","title":"MTKHelpers.get_concrete","text":"get_concrete(pset::AbstractProblemParSetter)\nget_concrete(pu::AbstractParameterUpdater)\n\nReturn a concrete-type-version of an ProblemParSetter or ProblemUpdater.\n\n\n\n\n\n","category":"function"},{"location":"concrete_parupdater/#Example","page":"Type inference","title":"Example","text":"","category":"section"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"The following example demonstrates, how to construct a cost function that is based on a closure in which the types are inferred.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"First, lets setup a small example problem","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"using OrdinaryDiffEq, ComponentArrays, MTKHelpers, Test, ModelingToolkit   \nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction get_sys1()\n    sts = @variables L(t)\n    ps = @parameters k_L, k_R, k_P\n    eq = [D(L) ~ 0]\n    sys1 = ODESystem(eq, t, sts, vcat(ps...); name = :sys1)\nend\nsys1 = mtkcompile(get_sys1())\nu0 = ComponentVector(L = 10.0)\np = ComponentVector(k_L = 1.0, k_R = 1 / 20, k_P = 2.0)\nprob = ODEProblem(sys1,\n    get_system_symbol_dict(sys1, u0), (0.0, 1.0),\n    get_system_symbol_dict(sys1, p))\nnothing # hide","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"Updating a problem with the default ProblemUpdater results in a non-type inferred problem.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"mapping = (:k_L => :k_R, :k_L => :k_P)\npg = KeysProblemParGetter(mapping, keys(u0)) \npu = get_ode_problemupdater(pg, get_system(prob))\nprob2 = pu(prob) # not inferred\nnothing # hide","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"But we can use get_concrete to obtain a type-inferred version. ","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"puc1 = get_concrete(pu)\n#prob3 = @inferred puc1(prob) # currently not working because remake not type-stable\nprob3 = puc1(prob)\nnothing # hide","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"This can be used to create a closure for a cost function that uses the type-stable variant.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"# get a concrete-type version of the ProblemParSetter and pass it \n# through a function barrier to a closure (function within let)\nget_fopt = (puc=get_concrete(pu)) -> let puc=puc\n    (prob) -> begin\n        #prob_upd = @inferred puc(prob) # TODO inferred\n        prob_upd = puc(prob)\n    end # fopt function\nend # let, get_fopt\nfopt = get_fopt()\n#prob4 = @inferred fopt(prob) # TODO inferred\nprob4 = fopt(prob)\nnothing # hide","category":"page"},{"location":"cairomakie/#CairoMakie-plotting-utils","page":"CairoMakie Helpers","title":"CairoMakie plotting utils","text":"","category":"section"},{"location":"cairomakie/#MTKHelpers.series_sol!","page":"CairoMakie Helpers","title":"MTKHelpers.series_sol!","text":"series_sol!(ax, sol::AbstractODESolution, vars; tspan=extrema(sol.t), labels=string.(vars), nt=120, kwargs...)\n\ncalls CairoMakie.series for a grid of n points and interpolated values from sol. vars is passed to the solution object and can contain observables. Currently works only with solutions created by a non-composite solver, e.g. Tsit5.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#Representing-a-system-as-a-component","page":"Embedding a system","title":"Representing a system as a component","text":"","category":"section"},{"location":"embed_system/#MTKHelpers.embed_system","page":"Embedding a system","title":"MTKHelpers.embed_system","text":"embed_system(m;name)\n\nEmbeds system m as the single component of a larger system. This helps to match the naming of the states, parameters, observables to  the namespace of the system. \n\nusing ModelingToolkit, OrdinaryDiffEq\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name) \n    sts = @variables x(t) RHS(t)  # RHS is observed\n    ps = @parameters τ       # parameters\n    ODESystem([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\n\n# note that keys are `m.x`,`m.τ` or `m.RHS`.\n# Hence only m needs to be defined rather than all the states, parameters, \n# and observables of the system.\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob, Tsit5());\ndx1 = sol[m.RHS][1:3] \ndx2 = sol[getproperty(m,:RHS)][1:3]  # access by symbols\n\n# using Plots\n# plot(sol, vars=[m.x,m.RHS])    \n# plot(sol, vars=getproperty.(Ref(m),[:x, :RHS])) # access by symbols\nlength(dx2) == 3\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#Overriding-equations-of-an-existing-system","page":"Embedding a system","title":"Overriding equations of an existing system","text":"","category":"section"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"For debugging bigger systems, it is helpful to set some equations to zero or modify/simplify the system in other ways.","category":"page"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"Function override_system takes a set of equations and matches the right-hand site to the equations of the original system and replaces those equations.","category":"page"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"# setting up a simple example composite system and problem\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name,τ = 3.0, p1=1.1, p2=1.2) \n    sts = @variables x(t) RHS(t)             # RHS is observed\n    ps = @parameters τ=τ p1=p1 p2=p2       # parameters\n    ODESystem([ RHS  ~ p1/p2 * (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n\n# simplify the system by setting RHS ~ RHS_0 * x\nfunction samplesystem_const(RHS0; name) \n    # demonstrating override_system by setting the RHS to constant first order rate\n    m = samplesystem(;name)\n    @unpack RHS,x = m\n    @parameters t \n    ps = @parameters RHS_0=RHS0\n    D = Differential(t)\n    eqs = [\n        RHS ~ RHS_0 * x,\n    ]\n    sys_ext = override_system(eqs, m; name, ps) \nend  \n\n@named mc = samplesystem_const(-0.1)\n@named sys = embed_system(mc)\nprob = ODEProblem(sys, [mc.x => 1.0], (0.0,10.0))\nsol = solve(prob, Tsit5())\nisapprox(sol(8)[1], exp(-0.1*8), atol = 1e-5)","category":"page"},{"location":"embed_system/#MTKHelpers.override_system","page":"Embedding a system","title":"MTKHelpers.override_system","text":"override_system(eqs, basesys::AbstractSystem; \n    name::Symbol=Symbol(string(nameof(basesys))*\"_ext\"), \n    ps=Term[], \n    obs=Equation[], \n    evs=ModelingToolkit.SymbolicContinuousCallback[], \n    defs=Dict()\n)\n\nModify basesys by replacing some equations matched by their left-hand-side. The keyword argument correspond to ODESystem.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#Utilities","page":"Embedding a system","title":"Utilities","text":"","category":"section"},{"location":"embed_system/#MTKHelpers.symbol_op","page":"Embedding a system","title":"MTKHelpers.symbol_op","text":"symbol_op(t)\n\nExtract the inner symbol_op from a Term, Num, or BasicSymbolic object.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#MTKHelpers.strip_namespace","page":"Embedding a system","title":"MTKHelpers.strip_namespace","text":"strip_namespace(s)\n\nOmit the part before the first dot.\n\n\n\n\n\n","category":"function"},{"location":"problemupdater/#ProblemUpdater","page":"ProblemUpdater","title":"ProblemUpdater","text":"","category":"section"},{"location":"problemupdater/#MTKHelpers.ProblemUpdater","page":"ProblemUpdater","title":"MTKHelpers.ProblemUpdater","text":"ProblemUpdater(par_getter, par_setter)\n\nEncapsulates updating an AbstractODEProblem based on the problem itself by  Callable (pu::ProblemUpdater)(prob).\n\nMust be initialized with a callable AbstractProblemParGetter,  e.g. KeysProblemParGetter and on a AbstractODEProblemParSetter, e.g. ODEProblemParSetter.\n\nThere are special functions to construct ProblemUpdater based on a given Problem:\n\nget_ode_problemupdater\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#MTKHelpers.get_ode_problemupdater","page":"ProblemUpdater","title":"MTKHelpers.get_ode_problemupdater","text":"get_ode_problemupdater(par_getter::AbstractProblemParGetter, u0, p)\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, sys::AbstractSystem)\n\nConstruct a ProblemUpdater based on an constructed ODEProblemParSetterConcrete.     \n\n\n\n\n\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, u0, p)\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, sys::AbstractSystem)\n\nConstruct a ProblemUpdater based on an constructed ODEProblemParSetterConcrete.     \n\n\n\n\n\n","category":"function"},{"location":"problemupdater/#MTKHelpers.NullProblemUpdater","page":"ProblemUpdater","title":"MTKHelpers.NullProblemUpdater","text":"AbstractProblemUpdater that returns the original AbstractODEProblem.\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#ProblemParGetter","page":"ProblemUpdater","title":"ProblemParGetter","text":"","category":"section"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"In order to provide computations for parameters to set, declare a concrete subtype of AbstractProblemParGetter, and implement a custom  method (pg::MyProblemParGetter)(pu::ProblemUpdater, prob) that returns a vector of parameter values. ","category":"page"},{"location":"problemupdater/#MTKHelpers.AbstractProblemParGetter","page":"ProblemUpdater","title":"MTKHelpers.AbstractProblemParGetter","text":"Supertype for callables that implement      (::AbstractProblemParGetter)(problem) -> updated_problem\n\nConcrete subtypes should implement function keys, so that an appropriate  AbstractODEProblemParSetter can be constructed for ProblemUpdater.\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"One simple subtype of AbstractProblemParGetter is KeysProblemParGetter,  which just extracts variables from the  original problem to update other parameters. It can be used to ensure that some parameter of a problem will always equal  another parameter of the problem. ","category":"page"},{"location":"problemupdater/#MTKHelpers.KeysProblemParGetter","page":"ProblemUpdater","title":"MTKHelpers.KeysProblemParGetter","text":"KeysProblemParGetter(mapping::NTuple{N,Pair{Symbol, Symbol}, keys_state)\n\nProvides callable (pg::KeysProblemParGetter)(pu::ProblemUpdater, prob), keys_state].     To be used to get the parameters/state vector to be set by ProblemUpdater.\n\nInitialize with an mapping of NTuples of symbols (source -> target) that index into  either get_state_labeled(pu.pset, prob) or get_par_labeled(pu.pset, prob)). Argument keys_state is a Tuple or Vector that iterates the Symbols in the state of an  ODEProblem. It is required to know from which part of the problem to extract.\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#ProblemParSetter","page":"ProblemUpdater","title":"ProblemParSetter","text":"","category":"section"},{"location":"problemupdater/#MTKHelpers.AbstractProblemParSetter","page":"ProblemUpdater","title":"MTKHelpers.AbstractProblemParSetter","text":"During an optimization, one does not want to recreate the problem from a symbolic system, but only update the problem. This can be difficult, because the parameters to update may be spread across initial state and other parameters.  Further, the order of parameters after simplifying a system is not fixed.\n\nA AbstractProblemUpdater helps with \n\nremake: translate the set of parameters -> an updated problem \nget_paropt: problem -> extract/approximate subset of parameters to optimize \n\nThe structure of optimized parameter Vector is described by an Axis object  of ComponentArrays.jl. And several functions are defined to work with it. Specifically, the ComponentVector it employs a classification (classes_paropt), ,e.g. :state and :par for ODEProblems, below which, ComponentVectors of actual parameters are listed (keys_paropt](@ref)). Further functions extract information about the ComponentVector: axis_paropt, , count_paropt,  symbols_paropt or attach information to a plain vector for convenient access or display: label_paropt, name_paropt. \n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#Translating-between-parameters-and-Problem","page":"ProblemUpdater","title":"Translating between parameters and Problem","text":"","category":"section"},{"location":"problemupdater/#SciMLBase.remake-Tuple{SciMLBase.AbstractSciMLProblem, Any, AbstractProblemParSetter}","page":"ProblemUpdater","title":"SciMLBase.remake","text":"remake(prob::AbstractSciMLProblem, popt, ps::AbstractProblemParSetter)\n\nReturn an updated problem given the parameters. Subtypes need to implement method remake_pset(prob, popt, pset)\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.get_paropt-Tuple{AbstractProblemParSetter, SciMLBase.AbstractSciMLProblem}","page":"ProblemUpdater","title":"MTKHelpers.get_paropt","text":"get_paropt(pset::AbstractProblemParSetter, prob::SciMLBase.AbstractSciMLProblem; kwargs...)\nget_paropt_labeled(pset::AbstractProblemParSetter, prob::SciMLBase.AbstractSciMLProblem; kwargs...)\n\nExtract optimized parameters from the Problem. The labeled versions additionally calls label_paropt on the return value.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#Helper-functions-to-access-optimized-parameters","page":"ProblemUpdater","title":"Helper functions to access optimized parameters","text":"","category":"section"},{"location":"problemupdater/#MTKHelpers.axis_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.axis_paropt","text":"axis_paropt(pset::AbstractProblemParSetter)\naxis_paropt_scalar(pset::AbstractProblemParSetter)\naxis_paropt_flat1(pset::AbstractProblemParSetter)\n\nReport the Axis of a ComponentVector of parameters. The second version has a scalarized entry for state for each subvector of state. The third version provides an axis corresponding to  flatten1(paropt).\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.classes_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.classes_paropt","text":"function classes_paropt(pset::AbstractProblemParSetter)\n\nGet the classes (as NTuple{Symbol}) which the AbstractProblemParSetter  supports and requires in paropt.        \n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.count_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.count_paropt","text":"count_paropt(::AbstractProblemParSetter)\n\nReport length of the optimized parameters vector.     This generally is different from the length of keys, because each key can describe a array.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.keys_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.keys_paropt","text":"keys_paropt(::AbstractProblemParSetter)\n\nReport the keys of paropt below the classification level.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.symbols_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.symbols_paropt","text":"symbols_paropt(pset::AbstractProblemParSetter)\n\nReport the names, i.e. symbols of optimized parameters respectively,  i.e. the concatenation of components. Similar to ComponentArrays.label, but inferred from Axis object.   Returns a Vector of length count_paropt\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#Labeling-parameter-vectors","page":"ProblemUpdater","title":"Labeling parameter vectors","text":"","category":"section"},{"location":"problemupdater/#MTKHelpers.label_paropt-Tuple{AbstractProblemParSetter, Any}","page":"ProblemUpdater","title":"MTKHelpers.label_paropt","text":"label_paropt(pset::AbstractProblemParSetter, popt::AbstractVector) \nlabel_paropt_flat1(pset::AbstractProblemParSetter, popt::AbstractVector)\n\nProduce a labeled version, i.e. a ComponentVector of optimized parameters. The second version omits the highest level of labels, e.g. state and par in  ODEProblemParSetter.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.name_paropt-Tuple{AbstractProblemParSetter, AbstractVector}","page":"ProblemUpdater","title":"MTKHelpers.name_paropt","text":"name_paropt(pset, popt::AbstractVector) \nname_paropt(pset, prob::AbstractSciMLProblem)\n\nProduce a NamedVector of given state optimized parameters vector. Similar to label_paropt, but may print nicer. The second form calls get_paropt on the Problem.\n\n\n\n\n\n","category":"method"},{"location":"updating_problems/#Setting-Initial-state-and-Parameters-of-a-problem","page":"Updating problems","title":"Setting Initial state and Parameters of a problem","text":"","category":"section"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Often one wants to change a subset of the initial states,u0, and a subset of parameters,p, of an AbstractODEProblem during an optimization.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Given u0 and p can be expressed as ComponentVectors,  then popt can be expressed as a ComponentVector of optimized parameters,  which may include initial states. The initial states and parameter components  must have different names.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"#The following example system employs a scalar and a vector-valued parameter.\n# using ModelingToolkit, OrdinaryDiffEq, ComponentArrays\n# using MTKHelpers\n# using ModelingToolkit: t_nounits as t, D_nounits as D\n# function samplesystem(;name,τ = 3.0, p=[1.1, 1.2]) \n#     sts = @variables x(t) RHS(t)        # RHS is observed\n#     ps = @parameters τ=τ p[1:2] = p \n#     ODESystem([ RHS  ~ p[1] + -p[2]*x + (1 - x)/τ, D(x) ~ RHS ], t, sts, vcat(ps...); name)\n# end                     \n# @named m = samplesystem()\n# @named sys = embed_system(m)\n# prob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0))\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"#The following example system employs a scalar and a vector-valued parameter.\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing ModelingToolkit: ModelingToolkit as MTK\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name,τ = 3.0, p1=1.1, p2=1.2) \n    sts = @variables x(t) RHS(t)        # RHS is observed\n    ps = @parameters τ=τ p1 = p1 p2 = p2\n    System([ RHS  ~ p1 + -p2*x + (1 - x)/τ, D(x) ~ RHS ], t, sts, vcat(ps...); name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0))\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"An ODEProblemParSetter then can be used to update a subset of states and parameters in the derived problem. Because the state of the problem can reorder components of a symbolic array and the parameter object of the problem is complex, use functions get_par(pset, prob) and get_state(pset, prob) or their labeled versions to  inspect state and parameters of a problem.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"# setup position matching, note τ is not in parameters optimized\npopt = ComponentVector(state=(m₊x=0.1,), par=(m₊p1=2.1,m₊p2=2.2)) \npset = ODEProblemParSetter(sys, popt) \n\n# extract optimized \nget_paropt(pset, prob)          # plain vector\nget_paropt_labeled(pset, prob)  # ComponentVector\nname_paropt(pset, prob)         # NamedVector \n\n# update states and parameters\nprob2 = remake(prob, popt, pset)\nget_par_labeled(pset, prob2).m₊p2 == popt.par.m₊p2 # attach labels and access properties\nget_state_labeled(pset, prob2).m₊x == popt.state.m₊x # attach labels and access properties\nget_paropt_labeled(pset, prob2) == popt\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"There are three  suggested ways in MTK10 is to","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"using an index object\nusing a setter object\nusing a SciMLStructures.jl to replace all tunable parameters","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"The first two, currently, do not work with AD systems. The third requires changing the system definition to adapt the parameters.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"#prob2 = remake(prob, [m.p2 => 3.2]) # would be nice, but not supported\nip2 = MTK.parameter_index(sys, MTK.parse_variable(sys, \"m₊p2\"))\nsetindex!(prob.ps, 3.2, ip2)\nprob.ps[m.p2] == 3.2\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Alternatively, use setter!  from SymbolicIndexingInterface.jl But this currently does not work with AD systems in Optimization.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"using SymbolicIndexingInterface\nsetter! = setp(sys, [m.p2])\nsetter!(prob, 4.2)\nprob.ps[m.p2] == 4.2\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Note that produced labeled ComponentArrays are not fully type-inferred, unless a concrete versions of the ParameterSetter and function barriers are used as described  in Concrete ProblemUpdater.","category":"page"},{"location":"updating_problems/#ProblemUpdater","page":"Updating problems","title":"ProblemUpdater","text":"","category":"section"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"A ODEProblemParSetterConcrete can be combined with a KeysProblemParGetter or another specific implementation of AbstractProblemParGetter to  update an AbstractODEProblem based on information already present in the AbstractODEProblem.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"The following example updates parameters k_R and k_P in the AbstractODEProblem to the value of k_L. This can be useful to ensure that these parameters are also changed when optimizing parameter k_L.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"An implementations of AbstractProblemParGetter can use any computation of the source keys to provide its destination keys. It should implement the keys method, so that when constructing the ProblemUpdater, consistent keys are used, as in the example below.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"First, create an example system and example problem.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"using ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nfunction get_sys1()\n    sts = @variables L(t)\n    ps = @parameters k_L, k_R, k_P\n    eq = [D(L) ~ 0]\n    sys1 = ODESystem(eq, t, sts, vcat(ps...); name = :sys1)\nend\nsys1 = mtkcompile(get_sys1())\nu0 = ComponentVector(L = 10.0)\np = ComponentVector(k_L = 1.0, k_R = 1 / 20, k_P = 2.0)\nprob = ODEProblem(sys1,\n    get_system_symbol_dict(sys1, u0), (0.0, 1.0),\n    get_system_symbol_dict(sys1, p))\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Next, setup a ProblemUpdater, pu, and apply it to the problem via prob2 = pu(prob).","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"mapping = (:k_L => :k_R, :k_L => :k_P)\npu = get_ode_problemupdater(KeysProblemParGetter(mapping, keys(u0)), get_system(prob))\nprob2 = pu(prob)\np2 = get_par_labeled(par_setter(pu), prob2)\np2.k_P == p.k_L\np2.k_R == p.k_L\nnothing # hide","category":"page"},{"location":"zindex/#Index","page":"index","title":"Index","text":"","category":"section"},{"location":"zindex/","page":"index","title":"index","text":"","category":"page"},{"location":"smoothstep/#Smooth-steps","page":"Smooth steps","title":"Smooth steps","text":"","category":"section"},{"location":"smoothstep/","page":"Smooth steps","title":"Smooth steps","text":"ODE solvers have a hard time with step changes, where the derivative changes discontinuously. The following function help to avoid associated problems by approximating the step by a smoother function. Argument dx controls the  smoothness.","category":"page"},{"location":"smoothstep/#MTKHelpers.smoothstep","page":"Smooth steps","title":"MTKHelpers.smoothstep","text":"smoothstep(x, x_step, dx, a=zero(x), b=one(x))\n\nsmooth step function: \n\n= a for x <= x_step - dx\n= b for x >= x_step + dx\n= (a-b)/2 for x == x_step\n\nand smooth in between.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#Translating-symbols-and-Nums","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"","category":"section"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"ModelingToolkit constructs an AbstractODEProblem from an ODESystem by supplying  Dictionaries that map Nums to values.  However, it is more convenient to store initial states and parameters as ComponentVectors with symbolic keys, instead of Dictionaries with Num keys.","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"First, lets create an example system that can demonstrate symbolic arrays in states and  parameters.","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"# setting up a simple example composite system and problem\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem_scalar(; name, τ = 3.0, i=0.1, p1 = 1.1, p2 = 1.2, p3 = 1.3)\n    @variables x1(t) x2(t)\n    ps = @parameters τ=τ i=i p1=p1 p2=p2 p3=p3\n    sts = [x1, x2]\n    eq = [\n        D(x1) ~ i - p1 * x1 + (p2 - x1^2) / τ, \n        D(x2) ~ i - p3 * x2, \n     ]\n     ODESystem(eq, t, sts, vcat(ps...); name)\nend\n@named m = samplesystem_scalar()\n@named sys = embed_system(m)\nnothing # hide","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"Next, we want to create the problem and need to specify the initial states and parameters as Dictionaries Num -> value. However, the Nums are only  defined within above function samplesystem_vec().","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"MTKHelpers provides method system_num_dict.","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"# setup initial conditions and parameters as ComponentVectors\nu0 = ComponentVector(m₊x1=0.1, m₊x2=0.2)\np = ComponentVector(m₊p1=2.1, m₊p2=2.2, m₊p3=2.3, m₊τ = 3.1) # keep i to default\n\n# convert to Dict(Num -> value) in order to create the AbstractODEProblem\np_numdict = system_num_dict(p, sys)\nu0_numdict = system_num_dict(u0, sys)\nprob = ODEProblem(sys, merge(u0_numdict, p_numdict), (0,2));\n\n# check the parameters of the created problem\npset = ODEProblemParSetter(sys, ComponentVector()) \np_prob = get_par_labeled(pset, prob)\np_prob.m₊i == 0.1     # from default\np_prob.m₊τ == p.m₊τ   # from p\np_prob.m₊p1 == p.m₊p1   # from p\nnothing # hide","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"MTKHelpers provides a remake variant with a ODEProblemParSetter,  that allows to update a subset of u0 and p of an AbstractODEProblem by providing a ComponentVector of parameters or initial states. ","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"paropt = ComponentVector(state=(m₊x1=10.1, m₊x2=10.2), par=(m₊τ = 10.1,))\npset = ODEProblemParSetter(get_system(prob), paropt)\nprob2 = remake(prob, paropt, pset)\np2_prob = get_par_labeled(pset, prob2); u2_prob = get_state_labeled(pset, prob2)\np2_prob.m₊τ == paropt.par.m₊τ     # from paropt\np2_prob.m₊p1 == p_prob.m₊p1         # from original prob\nu2_prob.m₊x1 == paropt.state.m₊x1\nnothing # hide","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"Note that the order of entries symbolic-array components in the state of the problem may differ from the consecutive order in the ComponentArray. Functions remake(prob, paropt, pset) and get_state(pset, prob) take care  to set and extract the components in correct order.","category":"page"},{"location":"system_num_dict_scalar/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"When updating an ODEProblem, MTKHelpers expects either a ComponentVector with sub-vectors state and par or, alternatively, a ComponentVector with keys of  states before keys of parameters. Function vcat_statesfirst helps to ensure this order when concatenating ComponentVectors.","category":"page"},{"location":"system_num_dict_scalar/#API","page":"Translating symbols and Nums","title":"API","text":"","category":"section"},{"location":"system_num_dict_scalar/#MTKHelpers.system_num_dict","page":"Translating symbols and Nums","title":"MTKHelpers.system_num_dict","text":"system_num_dict(d, sys::AbstractSystem)\nsystem_num_dict(d, symbol_dict::AbstractDict)\n\nCreate a Dictionary Num=>value from symbolic Dictionary or ComponentVector.\n\nOmit pairs where no Num was found.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.get_system","page":"Translating symbols and Nums","title":"MTKHelpers.get_system","text":"get_system(prob::AbstractODEProblem)\n\nGet the System associated to a problem.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.base_num","page":"Translating symbols and Nums","title":"MTKHelpers.base_num","text":"base_num(s)\n\nGet the symbol without an index, e.g. p[1] -> p, or x(t)[1] -> x(t).   \n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.get_base_num_dict","page":"Translating symbols and Nums","title":"MTKHelpers.get_base_num_dict","text":"get_base_num_dict(nums)\n\nReturn a Dictionary of Symbol -> Num, for each unique base_num.(nums)\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.vcat_statesfirst","page":"Translating symbols and Nums","title":"MTKHelpers.vcat_statesfirst","text":"vcat_statesfirst(cvs...; system)\n\nConcatenate ComponentVectors, cvs, but move state entries before parameter entries.   \n\n\n\n\n\n","category":"function"},{"location":"solution/#Indexing-into-the-solution","page":"Solution handling","title":"Indexing into the solution","text":"","category":"section"},{"location":"solution/#MTKHelpers.getlast","page":"Solution handling","title":"MTKHelpers.getlast","text":"getlast(sol, vars...)\ngetlast(sol, vars_vec)\n\nApply getindex for each var to sol and return a NamedArray.\n\nusing ModelingToolkit, OrdinaryDiffEq\nusing MTKHelpers\nusing NamedArrays\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name) \n    sts = @variables x(t) RHS(t)  # RHS is observed\n    ps = @parameters τ       # parameters\n    ODESystem([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob, Tsit5());\nres = getlast(sol, m.x, m.RHS)\nres == NamedArray([sol[m.x,end], sol[m.RHS,end]], ([m.x, m.RHS],))   \n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#MTKHelpers","page":"Home","title":"MTKHelpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MTKHelpers.","category":"page"},{"location":"odeproblemparsetter/#AbstractODEProblemParSetter","page":"ODEProblem","title":"AbstractODEProblemParSetter","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"The following type implements Translating between parameters and Problem for AbstractODEProblems.","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.AbstractODEProblemParSetter","page":"ODEProblem","title":"MTKHelpers.AbstractODEProblemParSetter","text":"Support translation between parameter vectors and  AbstractODEProblem.\n\nTakes care of mapping optimized parameters to subset of\n\nstate u0, and\nparameters p\n\nIn addition to the AbstractProblemParSetter functions, which accessing and labelling parameter vectors, it provides functions that access and label problem state and  parameters: axis_state, count_state,  keys_state, symbols_state, label_state,  name_state\n\n\n\n\n\n","category":"type"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"See the specific implementation ODEProblemParSetter. ","category":"page"},{"location":"odeproblemparsetter/#Helper-functions-to-access-state-and-parameters","page":"ODEProblem","title":"Helper functions to access state and parameters","text":"","category":"section"},{"location":"odeproblemparsetter/#MTKHelpers.axis_state","page":"ODEProblem","title":"MTKHelpers.axis_state","text":"axis_state(pset::AbstractODEProblemParSetter)\naxis_state_scalar(pset::AbstractODEProblemParSetter)\naxis_par(pset::AbstractODEProblemParSetter)\n\nReport the Axis, i.e. nested component symbols of problem states, and problem parameters respectively. There is a scalarized version, where symbolic arrays are scalarized, to support updating a subset of the indices. Returns an AbstractAxis.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.keys_state","page":"ODEProblem","title":"MTKHelpers.keys_state","text":"keys_state(::AbstractODEProblemParSetter) \nkeys_par(::AbstractODEProblemParSetter)\n\nReport the keys problem states, problem parameters.  This usually correspdonds to keys(axis), but if there is a classification, similar to keys_paropt, report the keys below this classification.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.count_state","page":"ODEProblem","title":"MTKHelpers.count_state","text":"count_state(::AbstractODEProblemParSetter) \ncount_par(::AbstractODEProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.symbols_state","page":"ODEProblem","title":"MTKHelpers.symbols_state","text":"symbols_state(sys::ODESystem)\nsymbols_par(sys::ODESystem)\n\nExtract the basic symbols without namespace of system states and system parameters.\n\n\n\n\n\nsymbols_state(pset::AbstractODEProblemParSetter)\nsymbols_par(pset::AbstractODEProblemParSetter)\nsymbols_paropt(pset::AbstractODEProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters respectively, i.e. the concatenation of components. Similar to ComponentArrays.label, but inferred from Axis object.   \n\nReports the scalarized version of symbolic array,  because the ordering of components is not fixed.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#Labeling","page":"ODEProblem","title":"Labeling","text":"","category":"section"},{"location":"odeproblemparsetter/#MTKHelpers.label_state-Tuple{AbstractODEProblemParSetter, Any}","page":"ODEProblem","title":"MTKHelpers.label_state","text":"label_state(pset::AbstractODEProblemParSetter, u::AbstractVector) \nlabel_par(pset::AbstractODEProblemParSetter, par::AbstractVector)\n\nProduce a labeled version, i.e. a ComponentVector of initial states, parameters  respectively.\n\n\n\n\n\n","category":"method"},{"location":"odeproblemparsetter/#MTKHelpers.name_state-Tuple{AbstractODEProblemParSetter, AbstractVector}","page":"ODEProblem","title":"MTKHelpers.name_state","text":"name_state(pset, u::AbstractVector) \nname_par(pset, par::AbstractVector)\n\nProduce a NamedVector of given state, parameters, or optimized vars.\n\n\n\n\n\n","category":"method"},{"location":"odeproblemparsetter/#ODEProblemParSetter","page":"ODEProblem","title":"ODEProblemParSetter","text":"","category":"section"},{"location":"odeproblemparsetter/#MTKHelpers.ODEProblemParSetter","page":"ODEProblem","title":"MTKHelpers.ODEProblemParSetter","text":"ODEProblemParSetter(state_template,par_template,popt_template) \nODEProblemParSetter(sys::ODESystem, popt_template)\n\nHelps keeping track of a subset of initial states and parameters to be optimized.\n\nArguments\n\nstate_template: ComponentVector or Axis of all the initial states of the problem\npar_template: all the parameters of the problem\npopt_template: the parameter/initial states to be optimized.  If given as Tuple or AbstractVector of symbols, then a template ComponentVector is extracted from state_template and par_template.\n\nIf all of state_template, par_template, and popt_template are type-inferred Axes, then also the constructed ODEProblemParSetter is type-inferred.\n\nThe states and parameters can be extracted from an ModelingToolkit.ODESystem.\n\nNote the similar ODEProblemParSetterConcrete with template parameters, which  supports type-stable calls (see Concrete ProblemUpdater).\n\n\n\n\n\n","category":"type"},{"location":"odeproblemparsetter/#ODEProblemParSetterConcrete","page":"ODEProblem","title":"ODEProblemParSetterConcrete","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"To support Concrete ProblemUpdater the following variant of  ODEProblemParSetter is provided.","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.ODEProblemParSetterConcrete","page":"ODEProblem","title":"MTKHelpers.ODEProblemParSetterConcrete","text":"ODEProblemParSetterConcrete\n\nHelps keeping track of a subset of initial states and parameters to be optimized. Similar to ODEProblemParSetter, but with axis and length information as type parameters.\n\nIt is constructed by get_concrete(ODEProblemParSetter(...)). `\n\n\n\n\n\n","category":"type"}]
}
