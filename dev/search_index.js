var documenterSearchIndex = {"docs":
[{"location":"write_csv_cv/#Reading-and-Writing-DataFrames-that-contain-ComponentArrays","page":"Writing/Reading ComponentVectors","title":"Reading and Writing DataFrames that contain ComponentArrays","text":"MTKHelpers supports setting parameters that are symbolic arrays, by specifying them as ComponentVector.\n\nTherefore, it is often useful to store parameters as ComponentVector in  one columns of a DataFrame. A DataFrame with such a columns, however,  is not easily written and retrieved from a interoperable file, such as CSV.\n\nThe following functions write and read data of such a DataFrame in CSV format that can be read by other tools. By using additional information on the Axes stored in comments, the ComponentVectors can be reconstructed.","category":"section"},{"location":"write_csv_cv/#MTKHelpers.write_csv_cv","page":"Writing/Reading ComponentVectors","title":"MTKHelpers.write_csv_cv","text":"write_csv_cv(con::IO, df0::DataFrame)\nread_csv_cv(con::IO)::DataFrame\n\nWrite/Read a DataFrame that contains columns of type ComponentArrays    to a CSV file. Each ComponentArray column is replaced by length(cv) columns, and information on the axis is generated as a comment in front of the CSV.\n\nWhen re-reading the CSV, the respective ComponentArrays are recreated  usingn this information and are replaced for the read plain columns.\n\nMake sure to not duplicate names. If there is a ComponentArray column u0 containing three Floats, the following three columns are added  (and should not exist before): u0_1, u0_2, u0_3.\n\n\n\n\n\n","category":"function"},{"location":"pde_dev/#PDE-support-developer-notes","page":"PDE support","title":"PDE support developer notes","text":"Since MTK version 10 the handling of parameters and initial values has become complex. Support for PDE has currently been dropped from MTKHelpers to support MKT >= version 10.","category":"section"},{"location":"pde_dev/#Depth-distributions","page":"PDE support","title":"Depth distributions","text":"The inputs to the system have to be described by a differential across depth. The following derivation provides an exponential function f(zb) = a e^bz, such that int_z_m^0 f(z) dz = 1. Such a function can be used to distribute total inputs across depth.\n\nDerivation: for positive x = -z:\n\nbeginaligned\nf(x) = a e^-bx\n\nF(x) = fraca-b e^-bx \n\nleft F(x) right_0^x_m = fraca-b left( e^-b x_m -1 right) = 1\n\na = fracb1 - e^-bx_m\n\nf(x) = fracb1 - e^-bx_m e^-bx\n\nF(x) = frac1e^-bx_m - 1 left( e^-bx -1 right)\nendaligned","category":"section"},{"location":"concrete_parupdater/#Concrete-ProblemUpdater","page":"Type inference","title":"Concrete ProblemUpdater","text":"The default-implementations of ODEParSetter and ParUpdater do not store much information in type parameters to avoid long compilation times.\n\nThe disadvantage is, that the result of some operations is not fully type- inferred, especially when dealing with ComponentArrays that store information in their type signature. The results of the folloginw calls are not inferred (x is stands in for either state, par, or paropt):\n\naxis_x(pset)\nlabel_x(pset, ...) \nget_paropt(pset, ...), and get_paropt_labeled(pset, ...)\nupdate_statepar and remake\ncount_x(pset) is inferred but no known at compile time and   can not be used to create StaticArrays\n\nTherefore, this package provides function get_concrete, that provides a concrete-typed version of a type.","category":"section"},{"location":"concrete_parupdater/#Example","page":"Type inference","title":"Example","text":"The following example demonstrates, how to construct a cost function that is based on a closure in which the types are inferred.\n\nFirst, lets setup a small example problem\n\nusing OrdinaryDiffEq, ComponentArrays, MTKHelpers, Test, ModelingToolkit   \nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction get_sys1()\n    sts = @variables L(t)\n    ps = @parameters k_L, k_R, k_P\n    eq = [D(L) ~ 0]\n    sys1 = System(eq, t, sts, vcat(ps...); name = :sys1)\nend\nsys1 = mtkcompile(get_sys1())\nu0 = ComponentVector(L = 10.0)\np = ComponentVector(k_L = 1.0, k_R = 1 / 20, k_P = 2.0)\nprob = ODEProblem(sys1,\n    vcat(get_system_symbol_dict(sys1, u0), get_system_symbol_dict(sys1, p)), \n    (0.0, 1.0))\nnothing # hide\n\nUpdating a problem with the default ProblemUpdater results in a non-type inferred problem.\n\nmapping = (:k_L => :k_R, :k_L => :k_P)\npg = KeysProblemParGetter(mapping, keys(u0)) \npu = get_ode_problemupdater(pg, get_system(prob))\nprob2 = pu(prob) # not inferred\nnothing # hide\n\nBut we can use get_concrete to obtain a type-inferred version. \n\npuc1 = get_concrete(pu)\nprob3 = @inferred puc1(prob) # currently not working because remake not type-stable\nnothing # hide\n\nThis can be used to create a closure for a cost function that uses the type-stable variant.\n\n# get a concrete-type version of the ProblemParSetter and pass it \n# through a function barrier to a closure (function within let)\nget_fopt = (puc=get_concrete(pu)) -> let puc=puc\n    (prob) -> begin\n        #prob_upd = @inferred puc(prob) # TODO inferred\n        prob_upd = puc(prob)\n    end # fopt function\nend # let, get_fopt\nfopt = get_fopt()\nprob4 = @inferred fopt(prob) # TODO inferred\nnothing # hide","category":"section"},{"location":"concrete_parupdater/#MTKHelpers.get_concrete","page":"Type inference","title":"MTKHelpers.get_concrete","text":"get_concrete(pset::AbstractProblemParSetter)\nget_concrete(pu::AbstractParameterUpdater)\n\nReturn a concrete-type-version of an ProblemParSetter or ProblemUpdater.\n\n\n\n\n\n","category":"function"},{"location":"cairomakie/#CairoMakie-plotting-utils","page":"CairoMakie Helpers","title":"CairoMakie plotting utils","text":"","category":"section"},{"location":"cairomakie/#MTKHelpers.series_sol!","page":"CairoMakie Helpers","title":"MTKHelpers.series_sol!","text":"series_sol!(ax, sol::AbstractODESolution, vars; tspan=extrema(sol.t), labels=string.(vars), nt=120, kwargs...)\n\ncalls CairoMakie.series for a grid of n points and interpolated values from sol. vars is passed to the solution object and can contain observables. Currently works only with solutions created by a non-composite solver, e.g. Tsit5.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#Representing-a-system-as-a-component","page":"Embedding a system","title":"Representing a system as a component","text":"","category":"section"},{"location":"embed_system/#Overriding-equations-of-an-existing-system","page":"Embedding a system","title":"Overriding equations of an existing system","text":"For debugging bigger systems, it is helpful to set some equations to zero or modify/simplify the system in other ways.\n\nFunction override_system takes a set of equations and matches the right-hand site to the equations of the original system and replaces those equations.\n\n# setting up a simple example composite system and problem\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name,τ = 3.0, p1=1.1, p2=1.2) \n    sts = @variables x(t) RHS(t)             # RHS is observed\n    ps = @parameters τ=τ p1=p1 p2=p2       # parameters\n    System([ RHS  ~ p1/p2 * (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n\n# simplify the system by setting RHS ~ RHS_0 * x\nfunction samplesystem_const(RHS0; name) \n    # demonstrating override_system by setting the RHS to constant first order rate\n    m = samplesystem(;name)\n    @unpack RHS,x = m\n    @parameters t \n    ps = @parameters RHS_0=RHS0\n    D = Differential(t)\n    eqs_new = [\n        RHS ~ RHS_0 * x,\n    ]\n    sys_ext = override_system(m; name, eqs_new, ps) \nend  \n\n@named mc = samplesystem_const(-0.1)\n@named sys = embed_system(mc)\nprob = ODEProblem(sys, [mc.x => 1.0], (0.0,10.0))\nsol = solve(prob, Tsit5())\nisapprox(sol(8)[1], exp(-0.1*8), atol = 1e-5)","category":"section"},{"location":"embed_system/#Utilities","page":"Embedding a system","title":"Utilities","text":"","category":"section"},{"location":"embed_system/#MTKHelpers.embed_system","page":"Embedding a system","title":"MTKHelpers.embed_system","text":"embed_system(m;name)\n\nEmbeds system m as the single component of a larger system. This helps to match the naming of the states, parameters, observables to  the namespace of the system. \n\nusing ModelingToolkit, OrdinaryDiffEq\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name) \n    sts = @variables x(t) RHS(t)  # RHS is observed\n    ps = @parameters τ       # parameters\n    System([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\n\n# note that keys are `m.x`,`m.τ` or `m.RHS`.\n# Hence only m needs to be defined rather than all the states, parameters, \n# and observables of the system.\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob, Tsit5());\ndx1 = sol[m.RHS][1:3] \ndx2 = sol[getproperty(m,:RHS)][1:3]  # access by symbols\n\n# using Plots\n# plot(sol, vars=[m.x,m.RHS])    \n# plot(sol, vars=getproperty.(Ref(m),[:x, :RHS])) # access by symbols\nlength(dx2) == 3\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#MTKHelpers.override_system","page":"Embedding a system","title":"MTKHelpers.override_system","text":"override_system(basesys::AbstractSystem; \n    eqs_new, \n    name::Symbol=Symbol(string(nameof(basesys))*\"_ext\"), \n    ps=Term[], \n    obs=Equation[], \n    evs=ModelingToolkit.SymbolicContinuousCallback[], \n    defs=Dict()\n)\n\nModify basesys by replacing some equations matched by their left-hand-side. The keyword argument correspond to ODESystem.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#MTKHelpers.symbol_op","page":"Embedding a system","title":"MTKHelpers.symbol_op","text":"symbol_op(t)\n\nExtract the inner symbol_op from a Term, Num, or BasicSymbolic object.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#MTKHelpers.strip_namespace","page":"Embedding a system","title":"MTKHelpers.strip_namespace","text":"strip_namespace(s)\n\nOmit the part before the first dot.\n\n\n\n\n\n","category":"function"},{"location":"updating_problems/#Setting-parts-of-initial-state-and-Parameters-of-a-problem","page":"Updating problems","title":"Setting parts of initial state and Parameters of a problem","text":"Often one wants to change a subset of the initial states,u0, and a subset of parameters,p, of an AbstractODEProblem during an optimization.\n\nGiven u0 and p can be expressed as ComponentVectors,  then popt can be expressed as a ComponentVector of optimized parameters,  which may include initial states. The initial states and parameter components  must have different names.\n\n#The following example system employs a scalar and a vector-valued parameter.\n# using ModelingToolkit, OrdinaryDiffEq, ComponentArrays\n# using MTKHelpers\n# using ModelingToolkit: t_nounits as t, D_nounits as D\n# function samplesystem(;name,τ = 3.0, p=[1.1, 1.2]) \n#     sts = @variables x(t) RHS(t)        # RHS is observed\n#     ps = @parameters τ=τ p[1:2] = p \n#     System([ RHS  ~ p[1] + -p[2]*x + (1 - x)/τ, D(x) ~ RHS ], t, sts, vcat(ps...); name)\n# end                     \n# @named m = samplesystem()\n# @named sys = embed_system(m)\n# prob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0))\nnothing # hide\n\n#The following example system employs a scalar-valued parameter.\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing ModelingToolkit: ModelingToolkit as MTK\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name,τ = 3.0, p1=1.1, p2=1.2) \n    sts = @variables x(t) RHS(t)        # RHS is observed\n    ps = @parameters τ=τ p1 = p1 p2 = p2\n    System([ RHS  ~ p1 + -p2*x + (1 - x)/τ, D(x) ~ RHS ], t, sts, vcat(ps...); name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0))\nnothing # hide\n\nAn ODEProblemParSetter then can be used to update a subset of states and parameters in the derived problem. Because the state of the problem can reorder components of a symbolic array the parameter object of the problem is complex.\n\n# setup position matching, note τ is not in parameters optimized\npopt = ComponentVector(state=(m₊x=0.1,), par=(m₊p1=2.1,m₊p2=2.2)) \npset = ODEProblemParSetter(sys, popt) \n\n# extract optimized state and parameters\nget_paropt(pset, prob)          # plain vector\nget_paropt_labeled(pset, prob)  # ComponentVector\nname_paropt(pset, prob)         # NamedVector \n\n# update states and parameters\nprob2 = remake(prob, popt, pset)\n\n# check that parameters have been updated\nget_paropt_labeled(pset, prob2) == popt\n# alternatively MTK access\nusing SymbolicIndexingInterface: SymbolicIndexingInterface as SII\nprob2.u0[SII.variable_index(sys, m.x)] == popt.state.m₊x\nprob2.ps[m.p1] == popt.par.m₊p1\nprob2.ps[:m₊p2] == popt.par.m₊p2\n\n# Further, check that other parameters did not change\nprob2.ps[m.τ] == initial_conditions(get_system(prob2))[m.τ]\nnothing # hide\n\nMTKHelper offers some convenience to access parameters, states, and optimized parts as a ComponentVector. pset stores the MTK indices so that they do not need to be recreated.\n\nget_state_labeled(pset, prob2).m₊x == popt.state.m₊x \nget_par_labeled(pset, prob2).m₊p2 == popt.par.m₊p2 \nget_paropt_labeled(pset, prob2) == popt\nnothing # hide\n\nThere are three  suggested ways since MTK10 is to\n\nusing an index object from SymbolicIndexingInterface.jl\nusing a setter object \nusing a SciMLStructures.jl to replace all tunable parameters\nusing the Dictionary interface\n\nCurrently only the 4th variant works without problems with AD systems, but it is not efficient. The third variant requires changing the system definition to determine which parameters are optimized. The first two need quite complex integration with PreallocationTools  to be used with AD-systems.\n\n#prob2 = remake(prob, [m.p2 => 3.2]) # would be nice, but not supported\nusing SymbolicIndexingInterface: SymbolicIndexingInterface as SII\nip2 = SII.parameter_index(sys, MTK.parse_variable(sys, \"m₊p2\"))\nsetindex!(prob.ps, 3.2, ip2)\nprob.ps[m.p2] == 3.2\nnothing # hide\n\nprobc = remake(prob)\nsetter! = SII.setp(sys, [m.p2])\nsetter!(probc, popt.par.m₊p2)\nprobc.ps[m.p2] == popt.par.m₊p2\nnothing # hide\n\nThis package currently in the background relies on the integration of setter objects with PreallocationTools.jl for supporting ForwardDiff and falls back on the Dictionary approach for other AD systems.\n\nusing ForwardDiff\ngr = ForwardDiff.gradient(\n    popt -> remake(prob, popt, pset).ps[m.p1], \n    getdata(popt))\ngr == [0.0, 1.0, 0.0]\nnothing # hide","category":"section"},{"location":"zindex/#Index","page":"index","title":"Index","text":"","category":"section"},{"location":"helpers/#Translating-between-parameters-and-Problem","page":"Helpers","title":"Translating between parameters and Problem","text":"","category":"section"},{"location":"helpers/#Helper-functions-to-access-optimized-parameters","page":"Helpers","title":"Helper functions to access optimized parameters","text":"","category":"section"},{"location":"helpers/#Labeling-parameter-vectors","page":"Helpers","title":"Labeling parameter vectors","text":"","category":"section"},{"location":"helpers/#ProblemUpdater","page":"Helpers","title":"ProblemUpdater","text":"The functioonality of ProblemUpdater can be better modeled since MTK version 10 using bindings.","category":"section"},{"location":"helpers/#Bindings","page":"Helpers","title":"Bindings","text":"First, create an example system and example problem.\n\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing ModelingToolkit: ModelingToolkit as MTK\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction get_sys1()\n    sts = @variables L(t)\n    ps = @parameters k_L, k_R, k_P\n    eq = [D(L) ~ 0]\n    sys1 = System(eq, t, sts, vcat(ps...); name = :sys1)\nend\nsys1 = mtkcompile(get_sys1())\nps1 = [sys1.L => 10.0, sys1.k_L => 1.0, sys1.k_R => 1.0/20.0, sys1.k_P => 2.0]\nprob = ODEProblem(sys1, ps1, (0.0, 1.0))\nnothing # hide\n\nThe bindings cannot be changed after the system is created.  MTKHelper provides function override_system that allows to create a new system with several properties changes. Note that this is has been developed and tested only for basic ODESystems.\n\nsys2 = mtkcompile(override_system(sys1, \n    bindings = [sys1.k_R => sys1.k_L / 20.0, sys1.k_P => sys1.k_L * 2.0]))\nps2 = [sys2.L => 10.0, sys2.k_L => 1.0]\nprob2 = ODEProblem(sys2, ps2, (0.0, 1.0))\nprob3 = remake(prob, p = [sys2.k_L => 1.1])\nprob.ps[sys2.k_P], prob2.ps[sys2.k_P]\n\nIf initial conditions are bound,  then initial conditions could be specified for the bound property instead of the original one.","category":"section"},{"location":"helpers/#Alternative:-Problemupdater","page":"Helpers","title":"Alternative: Problemupdater","text":"Bindings were introduced in MTK10. Before, a ProblemUpdater could be used to take care of updating dependent parameters.\n\nA ODEProblemParSetterConcrete can be combined with a KeysProblemParGetter or another specific implementation of AbstractProblemParGetter to  update an AbstractODEProblem based on information already present in the AbstractODEProblem.\n\nThe following example updates parameters k_R and k_P in the AbstractODEProblem to the value of k_L. This can be useful to ensure that these parameters are also changed when optimizing parameter k_L.\n\nAn implementations of AbstractProblemParGetter can use any computation of the source keys to provide its destination keys. It should implement the keys method, so that when constructing the ProblemUpdater, consistent keys are used, as in the example below.\n\nNext, setup a ProblemUpdater, pu, and apply it to the problem via prob2 = pu(prob).\n\nmapping = (:k_L => :k_R, :k_L => :k_P)\npu = get_ode_problemupdater(KeysProblemParGetter(mapping, prob), get_system(prob))\nprob2 = pu(prob)\np2 = get_par_labeled(par_setter(pu), prob2)\np2.k_P == p2.k_R == Dict(ps1)[sys1.k_L]\nnothing # hide","category":"section"},{"location":"helpers/#ProblemParGetter","page":"Helpers","title":"ProblemParGetter","text":"In order to provide computations for parameters to set, declare a concrete subtype of AbstractProblemParGetter, and implement a custom  method (pg::MyProblemParGetter)(pu::ProblemUpdater, prob) that returns a vector of parameter values. \n\nOne simple subtype of AbstractProblemParGetter is KeysProblemParGetter,  which just extracts variables from the  original problem to update other parameters. It can be used to ensure that some parameter of a problem will always equal  another parameter of the problem. ","category":"section"},{"location":"helpers/#ProblemParSetter","page":"Helpers","title":"ProblemParSetter","text":"Abstract supertype of ODEProblemParSetter","category":"section"},{"location":"helpers/#SciMLBase.remake-Tuple{SciMLBase.AbstractSciMLProblem, Any, AbstractProblemParSetter}","page":"Helpers","title":"SciMLBase.remake","text":"remake(prob::AbstractSciMLProblem, popt, ps::AbstractProblemParSetter)\n\nReturn an updated problem given the parameters. Subtypes need to implement method remake_pset(prob, popt, pset)\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.get_paropt-Tuple{AbstractProblemParSetter, SciMLBase.AbstractSciMLProblem}","page":"Helpers","title":"MTKHelpers.get_paropt","text":"get_paropt(pset::AbstractProblemParSetter, prob::SciMLBase.AbstractSciMLProblem; kwargs...)\nget_paropt_labeled(pset::AbstractProblemParSetter, prob::SciMLBase.AbstractSciMLProblem; kwargs...)\n\nExtract optimized parameters from the Problem. The labeled versions additionally calls label_paropt on the return value.\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.axis_paropt-Tuple{AbstractProblemParSetter}","page":"Helpers","title":"MTKHelpers.axis_paropt","text":"axis_paropt(pset::AbstractProblemParSetter)\naxis_paropt_scalar(pset::AbstractProblemParSetter)\naxis_paropt_flat1(pset::AbstractProblemParSetter)\n\nReport the Axis of a ComponentVector of parameters. The second version has a scalarized entry for state for each subvector of state. The third version provides an axis corresponding to  flatten1(paropt).\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.classes_paropt-Tuple{AbstractProblemParSetter}","page":"Helpers","title":"MTKHelpers.classes_paropt","text":"function classes_paropt(pset::AbstractProblemParSetter)\n\nGet the classes (as NTuple{Symbol}) which the AbstractProblemParSetter  supports and requires in paropt.        \n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.count_paropt-Tuple{AbstractProblemParSetter}","page":"Helpers","title":"MTKHelpers.count_paropt","text":"count_paropt(::AbstractProblemParSetter)\n\nReport length of the optimized parameters vector.     This generally is different from the length of keys, because each key can describe a array.\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.keys_paropt-Tuple{AbstractProblemParSetter}","page":"Helpers","title":"MTKHelpers.keys_paropt","text":"keys_paropt(::AbstractProblemParSetter)\n\nReport the keys of paropt below the classification level.\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.symbols_paropt-Tuple{AbstractProblemParSetter}","page":"Helpers","title":"MTKHelpers.symbols_paropt","text":"symbols_paropt(pset::AbstractProblemParSetter)\n\nReport the names, i.e. symbols of optimized parameters respectively,  i.e. the concatenation of components. Similar to ComponentArrays.label, but inferred from Axis object.   Returns a Vector of length count_paropt\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.label_paropt-Tuple{AbstractProblemParSetter, Any}","page":"Helpers","title":"MTKHelpers.label_paropt","text":"label_paropt(pset::AbstractProblemParSetter, popt::AbstractVector) \nlabel_paropt_flat1(pset::AbstractProblemParSetter, popt::AbstractVector)\n\nProduce a labeled version, i.e. a ComponentVector of optimized parameters. The second version omits the highest level of labels, e.g. state and par in  ODEProblemParSetter.\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.name_paropt-Tuple{AbstractProblemParSetter, AbstractVector}","page":"Helpers","title":"MTKHelpers.name_paropt","text":"name_paropt(pset, popt::AbstractVector) \nname_paropt(pset, prob::AbstractSciMLProblem)\n\nProduce a NamedVector of given state optimized parameters vector. Similar to label_paropt, but may print nicer. The second form calls get_paropt on the Problem.\n\n\n\n\n\n","category":"method"},{"location":"helpers/#MTKHelpers.ProblemUpdater","page":"Helpers","title":"MTKHelpers.ProblemUpdater","text":"ProblemUpdater(par_getter, par_setter)\n\nEncapsulates updating an AbstractODEProblem based on the problem itself by  Callable (pu::ProblemUpdater)(prob).\n\nMust be initialized with a callable AbstractProblemParGetter,  e.g. KeysProblemParGetter and on a AbstractODEProblemParSetter, e.g. ODEProblemParSetter.\n\nThere are special functions to construct ProblemUpdater based on a given Problem:\n\nget_ode_problemupdater\n\n\n\n\n\n","category":"type"},{"location":"helpers/#MTKHelpers.get_ode_problemupdater","page":"Helpers","title":"MTKHelpers.get_ode_problemupdater","text":"get_ode_problemupdater(par_getter::AbstractProblemParGetter, u0, p)\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, sys::AbstractSystem)\n\nConstruct a ProblemUpdater based on an constructed ODEProblemParSetterConcrete.     \n\n\n\n\n\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, u0, p)\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, sys::AbstractSystem)\n\nConstruct a ProblemUpdater based on an constructed ODEProblemParSetterConcrete.     \n\n\n\n\n\n","category":"function"},{"location":"helpers/#MTKHelpers.NullProblemUpdater","page":"Helpers","title":"MTKHelpers.NullProblemUpdater","text":"AbstractProblemUpdater that returns the original AbstractODEProblem.\n\n\n\n\n\n","category":"type"},{"location":"helpers/#MTKHelpers.AbstractProblemParGetter","page":"Helpers","title":"MTKHelpers.AbstractProblemParGetter","text":"Supertype for callables that implement      (::AbstractProblemParGetter)(problem) -> updated_problem\n\nConcrete subtypes should implement function keys, so that an appropriate  AbstractODEProblemParSetter can be constructed for ProblemUpdater.\n\n\n\n\n\n","category":"type"},{"location":"helpers/#MTKHelpers.KeysProblemParGetter","page":"Helpers","title":"MTKHelpers.KeysProblemParGetter","text":"KeysProblemParGetter(mapping::NTuple{N,Pair{Symbol, Symbol}, keys_state)\n\nProvides callable (pg::KeysProblemParGetter)(pu::ProblemUpdater, prob), keys_state].     To be used to get the parameters/state vector to be set by ProblemUpdater.\n\nInitialize with an mapping of NTuples of symbols (source -> target) that index into  either get_state_labeled(pu.pset, prob) or get_par_labeled(pu.pset, prob)). Argument keys_state is a Tuple or Vector that iterates the Symbols in the state of an  ODEProblem. It is required to know from which part of the problem to extract.\n\n\n\n\n\n","category":"type"},{"location":"helpers/#MTKHelpers.AbstractProblemParSetter","page":"Helpers","title":"MTKHelpers.AbstractProblemParSetter","text":"During an optimization, one does not want to recreate the problem from a symbolic system, but only update the problem. This can be difficult, because the parameters to update may be spread across initial state and other parameters.  Further, the order of parameters after simplifying a system is not fixed.\n\nA AbstractProblemUpdater helps with \n\nremake: translate the set of parameters -> an updated problem \nget_paropt: problem -> extract/approximate subset of parameters to optimize \n\nThe structure of optimized parameter Vector is described by an Axis object  of ComponentArrays.jl. And several functions are defined to work with it. Specifically, the ComponentVector it employs a classification (classes_paropt), ,e.g. :state and :par for ODEProblems, below which, ComponentVectors of actual parameters are listed (keys_paropt](@ref)). Further functions extract information about the ComponentVector: axis_paropt, , count_paropt,  symbols_paropt or attach information to a plain vector for convenient access or display: label_paropt, name_paropt. \n\n\n\n\n\n","category":"type"},{"location":"smoothstep/#Smooth-steps","page":"Smooth steps","title":"Smooth steps","text":"ODE solvers have a hard time with step changes, where the derivative changes discontinuously. The following function help to avoid associated problems by approximating the step by a smoother function. Argument dx controls the  smoothness.","category":"section"},{"location":"smoothstep/#MTKHelpers.smoothstep","page":"Smooth steps","title":"MTKHelpers.smoothstep","text":"smoothstep(x, x_step, dx, a=zero(x), b=one(x))\n\nsmooth step function: \n\n= a for x <= x_step - dx\n= b for x >= x_step + dx\n= (a-b)/2 for x == x_step\n\nand smooth in between.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#Translating-symbols-and-Nums","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"ModelingToolkit constructs an AbstractODEProblem from an ODESystem by supplying  Dictionaries that map Nums to values.  However, it is more convenient to store initial states and parameters as ComponentVectors with symbolic keys, instead of Dictionaries with Num keys.\n\nFirst, lets create an example system that can demonstrate symbolic arrays in states and  parameters.\n\n# setting up a simple example composite system and problem\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem_scalar(; name, τ = 3.0, i=0.1, p1 = 1.1, p2 = 1.2, p3 = 1.3)\n    @variables x1(t) x2(t)\n    ps = @parameters τ=τ i=i p1=p1 p2=p2 p3=p3\n    sts = [x1, x2]\n    eq = [\n        D(x1) ~ i - p1 * x1 + (p2 - x1^2) / τ, \n        D(x2) ~ i - p3 * x2, \n     ]\n     System(eq, t, sts, vcat(ps...); name)\nend\n@named m = samplesystem_scalar()\n@named sys = embed_system(m)\nnothing # hide\n\nNext, we want to create the problem and need to specify the initial states and parameters as Dictionaries Num -> value. However, the Nums are only  defined within above function samplesystem_vec().\n\nMTKHelpers provides method system_num_dict.\n\n# setup initial conditions and parameters as ComponentVectors\nu0 = ComponentVector(m₊x1=0.1, m₊x2=0.2)\np = ComponentVector(m₊p1=2.1, m₊p2=2.2, m₊p3=2.3, m₊τ = 3.1) # keep i to default\n\n# convert to Dict(Num -> value) in order to create the AbstractODEProblem\np_numdict = system_num_dict(p, sys)\nu0_numdict = system_num_dict(u0, sys)\nprob = ODEProblem(sys, merge(u0_numdict, p_numdict), (0,2));\n\n# check the parameters of the created problem\npset = ODEProblemParSetter(sys, ComponentVector()) \np_prob = get_par_labeled(pset, prob)\np_prob.m₊i == 0.1     # from default\np_prob.m₊τ == p.m₊τ   # from p\np_prob.m₊p1 == p.m₊p1   # from p\nnothing # hide\n\nMTKHelpers provides a remake variant with a ODEProblemParSetter,  that allows to update a subset of u0 and p of an AbstractODEProblem by providing a ComponentVector of parameters or initial states. \n\nparopt = ComponentVector(state=(m₊x1=10.1, m₊x2=10.2), par=(m₊τ = 10.1,))\npset = ODEProblemParSetter(get_system(prob), paropt)\nprob2 = remake(prob, paropt, pset)\np2_prob = get_par_labeled(pset, prob2); u2_prob = get_state_labeled(pset, prob2)\np2_prob.m₊τ == paropt.par.m₊τ     # from paropt\np2_prob.m₊p1 == p_prob.m₊p1         # from original prob\nu2_prob.m₊x1 == paropt.state.m₊x1\nnothing # hide\n\nNote that the order of entries symbolic-array components in the state of the problem may differ from the consecutive order in the ComponentArray. Functions remake(prob, paropt, pset) and get_state(pset, prob) take care  to set and extract the components in correct order.\n\nWhen updating an ODEProblem, MTKHelpers expects either a ComponentVector with sub-vectors state and par or, alternatively, a ComponentVector with keys of  states before keys of parameters. Function vcat_statesfirst helps to ensure this order when concatenating ComponentVectors.","category":"section"},{"location":"system_num_dict_scalar/#API","page":"Translating symbols and Nums","title":"API","text":"","category":"section"},{"location":"system_num_dict_scalar/#MTKHelpers.system_num_dict","page":"Translating symbols and Nums","title":"MTKHelpers.system_num_dict","text":"system_num_dict(d, sys::AbstractSystem)\nsystem_num_dict(d, symbol_dict::AbstractDict)\n\nCreate a Dictionary Num=>value from symbolic Dictionary or ComponentVector.\n\nOmit pairs where no Num was found.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.get_system","page":"Translating symbols and Nums","title":"MTKHelpers.get_system","text":"get_system(prob::AbstractODEProblem)\n\nGet the System associated to a problem.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.base_num","page":"Translating symbols and Nums","title":"MTKHelpers.base_num","text":"base_num(s)\n\nGet the symbol without an index, e.g. p[1] -> p, or x(t)[1] -> x(t).   \n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.get_base_num_dict","page":"Translating symbols and Nums","title":"MTKHelpers.get_base_num_dict","text":"get_base_num_dict(nums)\n\nReturn a Dictionary of Symbol -> Num, for each unique base_num.(nums)\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict_scalar/#MTKHelpers.vcat_statesfirst","page":"Translating symbols and Nums","title":"MTKHelpers.vcat_statesfirst","text":"vcat_statesfirst(cvs...; system)\n\nConcatenate ComponentVectors, cvs, but move state entries before parameter entries.   \n\n\n\n\n\n","category":"function"},{"location":"solution/#Indexing-into-the-solution","page":"Solution handling","title":"Indexing into the solution","text":"","category":"section"},{"location":"solution/#MTKHelpers.getlast","page":"Solution handling","title":"MTKHelpers.getlast","text":"getlast(sol, vars...)\ngetlast(sol, vars_vec)\n\nApply getindex for each var to sol and return a NamedArray.\n\nusing ModelingToolkit, OrdinaryDiffEq\nusing MTKHelpers\nusing NamedArrays\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction samplesystem(;name) \n    sts = @variables x(t) RHS(t)  # RHS is observed\n    ps = @parameters τ       # parameters\n    System([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob, Tsit5());\nres = getlast(sol, m.x, m.RHS)\nres == NamedArray([sol[m.x,end], sol[m.RHS,end]], ([m.x, m.RHS],))   \n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#MTKHelpers","page":"Home","title":"MTKHelpers","text":"Documentation for MTKHelpers.","category":"section"},{"location":"odeproblemparsetter/#AbstractODEProblemParSetter","page":"ODEProblem","title":"AbstractODEProblemParSetter","text":"The following type implements Translating between parameters and Problem for AbstractODEProblems.\n\nSee the specific implementation ODEProblemParSetter. ","category":"section"},{"location":"odeproblemparsetter/#Helper-functions-to-access-state-and-parameters","page":"ODEProblem","title":"Helper functions to access state and parameters","text":"","category":"section"},{"location":"odeproblemparsetter/#Labeling","page":"ODEProblem","title":"Labeling","text":"","category":"section"},{"location":"odeproblemparsetter/#ODEProblemParSetter","page":"ODEProblem","title":"ODEProblemParSetter","text":"","category":"section"},{"location":"odeproblemparsetter/#ODEProblemParSetterConcrete","page":"ODEProblem","title":"ODEProblemParSetterConcrete","text":"To support Concrete ProblemUpdater the following variant of  ODEProblemParSetter is provided.","category":"section"},{"location":"odeproblemparsetter/#MTKHelpers.AbstractODEProblemParSetter","page":"ODEProblem","title":"MTKHelpers.AbstractODEProblemParSetter","text":"Support translation between parameter vectors and  AbstractODEProblem.\n\nTakes care of mapping optimized parameters to subset of\n\nstate u0, and\nparameters p\n\nIn addition to the AbstractProblemParSetter functions, which accessing and labelling parameter vectors, it provides functions that access and label problem state and  parameters: axis_state, count_state,  keys_state, symbols_state, label_state,  name_state\n\n\n\n\n\n","category":"type"},{"location":"odeproblemparsetter/#MTKHelpers.axis_state","page":"ODEProblem","title":"MTKHelpers.axis_state","text":"axis_state(pset::AbstractODEProblemParSetter)\naxis_state_scalar(pset::AbstractODEProblemParSetter)\naxis_par(pset::AbstractODEProblemParSetter)\n\nReport the Axis, i.e. nested component symbols of problem states, and problem parameters respectively. There is a scalarized version, where symbolic arrays are scalarized, to support updating a subset of the indices. Returns an AbstractAxis.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.keys_state","page":"ODEProblem","title":"MTKHelpers.keys_state","text":"keys_state(::AbstractODEProblemParSetter) \nkeys_par(::AbstractODEProblemParSetter)\n\nReport the keys problem states, problem parameters.  This usually correspdonds to keys(axis), but if there is a classification, similar to keys_paropt, report the keys below this classification.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.count_state","page":"ODEProblem","title":"MTKHelpers.count_state","text":"count_state(::AbstractODEProblemParSetter) \ncount_par(::AbstractODEProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.symbols_state","page":"ODEProblem","title":"MTKHelpers.symbols_state","text":"symbols_state(sys::ODESystem)\nsymbols_par(sys::ODESystem)\n\nExtract the basic symbols without namespace of system states and system parameters.\n\n\n\n\n\nsymbols_state(pset::AbstractODEProblemParSetter)\nsymbols_par(pset::AbstractODEProblemParSetter)\nsymbols_paropt(pset::AbstractODEProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters respectively, i.e. the concatenation of components. Similar to ComponentArrays.label, but inferred from Axis object.   \n\nReports the scalarized version of symbolic array,  because the ordering of components is not fixed.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.label_state-Tuple{AbstractODEProblemParSetter, Any}","page":"ODEProblem","title":"MTKHelpers.label_state","text":"label_state(pset::AbstractODEProblemParSetter, u::AbstractVector) \nlabel_par(pset::AbstractODEProblemParSetter, par::AbstractVector)\n\nProduce a labeled version, i.e. a ComponentVector of initial states, parameters  respectively.\n\n\n\n\n\n","category":"method"},{"location":"odeproblemparsetter/#MTKHelpers.name_state-Tuple{AbstractODEProblemParSetter, AbstractVector}","page":"ODEProblem","title":"MTKHelpers.name_state","text":"name_state(pset, u::AbstractVector) \nname_par(pset, par::AbstractVector)\n\nProduce a NamedVector of given state, parameters, or optimized vars.\n\n\n\n\n\n","category":"method"},{"location":"odeproblemparsetter/#MTKHelpers.ODEProblemParSetter","page":"ODEProblem","title":"MTKHelpers.ODEProblemParSetter","text":"ODEProblemParSetter(state_template,par_template,popt_template) \nODEProblemParSetter(sys::ODESystem, popt_template)\n\nHelps keeping track of a subset of initial states and parameters to be optimized.\n\nArguments\n\nstate_template: ComponentVector or Axis of all the initial states of the problem\npar_template: all the parameters of the problem\npopt_template: the parameter/initial states to be optimized.  If given as Tuple or AbstractVector of symbols, then a template ComponentVector is extracted from state_template and par_template.\n\nIf all of state_template, par_template, and popt_template are type-inferred Axes, then also the constructed ODEProblemParSetter is type-inferred.\n\nThe states and parameters can be extracted from an ModelingToolkit.ODESystem.\n\nNote the similar ODEProblemParSetterConcrete with template parameters, which  supports type-stable calls (see Concrete ProblemUpdater).\n\n\n\n\n\n","category":"type"},{"location":"odeproblemparsetter/#MTKHelpers.ODEProblemParSetterConcrete","page":"ODEProblem","title":"MTKHelpers.ODEProblemParSetterConcrete","text":"ODEProblemParSetterConcrete\n\nHelps keeping track of a subset of initial states and parameters to be optimized. Similar to ODEProblemParSetter, but with axis and length information as type parameters.\n\nIt is constructed by get_concrete(ODEProblemParSetter(...)). `\n\n\n\n\n\n","category":"type"}]
}
